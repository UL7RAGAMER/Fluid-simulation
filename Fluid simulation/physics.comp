#version 430 core

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer PositionBuffer {
    vec2 positions[];
};

layout(std430, binding = 1) buffer VelocityBuffer {
    vec2 velocities[];
};

// Uniforms are global variables sent from our C++ application.
uniform float deltaTime;
uniform float gravity;
uniform float u_time; 
uniform int is_mouse_pressed;
uniform vec2 mouse_pos;
// --- Pseudo-random number generator ---
// A simple hashing function that takes a seed and produces a float between 0.0 and 1.0
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

void main() {
    uint id = gl_GlobalInvocationID.x;

    // --- The Physics Logic ---
    float boundary_left = -1.0;
    float boundary_right = 1.0;
    float boundary_bottom = -1.0;
    float boundary_top = 1.0;

    // 1. Apply Gravity
    
    if(is_mouse_pressed == 1) {
        vec2 force = (mouse_pos - positions[id]);
        velocities[id] += force * deltaTime * 5.0 ; // The '5.0' is a strength multiplier
        float damping = 0.95;
        velocities[id] *= damping;
    }
    velocities[id].y -= gravity * deltaTime;
    // 2. Update Position
    positions[id] += velocities[id] * deltaTime;

    // 3. Handle Collisions
    if (positions[id].x > boundary_right) {
        positions[id].x = boundary_right;
        // Reverse and apply random damping (e.g., between -0.4 and -0.8)
        velocities[id].x *= - (0.4 + 0.4 * random(vec2(id, u_time))/2);
    } else if (positions[id].x < boundary_left) {
        positions[id].x = boundary_left;
        float rand = random(vec2(id, u_time * 1.1)); // slightly different seed
        velocities[id].x *= - (0.4 + 0.4 * random(vec2(id, u_time))/2);
    }

    if (positions[id].y < boundary_bottom) {
        positions[id].y = boundary_bottom;
        float rand = random(vec2(id, u_time * 1.2)); // slightly different seed
        velocities[id].y *= - (0.4 + 0.4 * random(vec2(id, u_time))*2);
    } else if (positions[id].y > boundary_top) {
        positions[id].y = boundary_top;
        float rand = random(vec2(id, u_time * 1.3)); // slightly different seed
        velocities[id].y *= - (0.4 + 0.4 * random(vec2(id, u_time))*2);
    }
}
