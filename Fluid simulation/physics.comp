#version 430 core
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

// BINDING 0: Particle Positions (Read/Write)
layout(std430, binding = 0) buffer PositionBuffer {
    vec2 positions[];
};

// BINDING 1: Particle Velocities (Read/Write)
layout(std430, binding = 1) buffer VelocityBuffer {
    vec2 velocities[];
};

// BINDING 2: Particle Densities (Read-only)
layout(std430, binding = 2) readonly buffer DensityBuffer {
    float densities[];
};

// BINDING 3: Particle Pressures (Read-only)
layout(std430, binding = 3) readonly buffer PressureBuffer {
    float pressures[];
};


// --- Uniforms ---
uniform uint particleCount;
uniform float deltaTime;
uniform float gravity;
uniform float u_time; // For random damping
uniform float is_mouse_pressed;
uniform vec2 mouse_pos;
// --- SPH Parameters ---
uniform float particleMass;
uniform float smoothingRadius;
uniform float viscosityConstant;
uniform float boundaryDamping;
uniform float boundaryStiffness;
uniform float pressure_multipiler;
// --- SPH Kernel Function Gradients/Laplacians ---
const float PI = 3.14159265359;
const float SPIKY_GRAD_COEFF = -45.0 / PI;
const float VISC_LAP_COEFF = 45.0 / PI;


vec2 force_boundary = vec2(0.0);


float spiky_kernel_gradient(float dist, float h) {
    if (dist > h) return 0.0;
    float term = h - dist;
    return (SPIKY_GRAD_COEFF / pow(h, 6.0)) * term * term;
}

float viscosity_kernel_laplacian(float dist, float h) {
    if (dist > h) return 0.0;
    return (VISC_LAP_COEFF / pow(h, 6.0)) * (h - dist);
}

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= particleCount) return;

    // Read particle's own data
    vec2 pos_i = positions[id];
    vec2 vel_i = velocities[id];
    float density_i = densities[id];
    float pressure_i = pressures[id];

    if (density_i < 0.0001) {
        density_i = 0.0001;
    }

    // Initialize forces
    vec2 force_pressure = vec2(0.0);
    vec2 force_viscosity = vec2(0.0);
    // CHANGE 1: Initialize a mouse force vector
    vec2 force_mouse = vec2(0.0);

    // Calculate forces by iterating through all other particles
    for (uint j = 0; j < particleCount; j++) {
        if (id == j) continue;

        vec2 r_vec = pos_i - positions[j];
        float dist = length(r_vec);

        if (dist > 0.0 && dist < smoothingRadius) {
            vec2 r_dir = r_vec / dist;
            float density_j = densities[j];
            
            // Pressure Force
            float shared_pressure = (pressure_i + pressures[j]) / 2.0;
            vec2 pressure_grad = r_dir * particleMass * (shared_pressure / density_j) * spiky_kernel_gradient(dist, smoothingRadius);
            force_pressure -= pressure_grad * pressure_multipiler;

            // Viscosity Force
            float visc_lap = viscosity_kernel_laplacian(dist, smoothingRadius);
            vec2 vel_diff = velocities[j] - vel_i;
            force_viscosity += viscosityConstant * particleMass * vel_diff / density_j * visc_lap;
        }
    }
    
    // External Force (Gravity)
    vec2 force_gravity = vec2(0.0, -gravity) * density_i;

    // CHANGE 2: Calculate the mouse force here, before integration
    // Using "> 0.5" is safer for floats than "== 1.0"
    if (is_mouse_pressed > 0.5) {
        vec2 from_mouse = pos_i - mouse_pos;
        float dist_to_mouse = length(from_mouse);
        float mouse_radius = 0.5; // The mouse will only affect particles within this radius

        if (dist_to_mouse < mouse_radius) {
            // This creates a force that pushes particles away from the mouse, getting weaker with distance
            force_mouse = -normalize(from_mouse) * 25.0 * (mouse_radius + dist_to_mouse);
        }
    }

    // --- INTEGRATE ---
    // CHANGE 3: Add the mouse force to the total force calculation
    vec2 total_force = force_pressure + force_viscosity + force_gravity + force_mouse + force_boundary;
    vec2 acceleration = total_force / density_i;
    
    vel_i += acceleration * deltaTime;
    pos_i += vel_i * deltaTime;

    // --- BOUNDARY COLLISION ---
    float boundary_limit = 1.0; // The boundary is at -1.0 and 1.0
    float boundary_radius = 0.05; // How far from the wall the force starts acting

    // Left Wall
    float dist_left = pos_i.x - (-boundary_limit);
    if (dist_left < boundary_radius) {
        force_boundary.x += boundaryStiffness * (boundary_radius - dist_left);
        vel_i.x *= -boundaryDamping; // Reverse and dampen velocity
    }

    // Right Wall
    float dist_right = (boundary_limit) - pos_i.x;
    if (dist_right < boundary_radius) {
        force_boundary.x -= boundaryStiffness * (boundary_radius - dist_right);
        vel_i.x *= -boundaryDamping;
    }

    // Bottom Wall
    float dist_bottom = pos_i.y - (-boundary_limit);
    if (dist_bottom < boundary_radius) {
        force_boundary.y += boundaryStiffness * (boundary_radius - dist_bottom);
        vel_i.y *= -boundaryDamping;
    }

    // Top Wall
    float dist_top = (boundary_limit) - pos_i.y;
    if (dist_top < boundary_radius) {
        force_boundary.y -= boundaryStiffness * (boundary_radius - dist_top);
        vel_i.y *= -boundaryDamping;
    }

    // --- WRITE FINAL DATA ---
    positions[id] = pos_i;
    velocities[id] = vel_i;

    // CHANGE 4: Delete the old, incorrect mouse interaction code from the end of the shader.
}
