#version 430 core

// Define the size of a "work group". This is how many threads we run in a block.
// 128 is a common and efficient size.
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

// Define the buffer structures that will hold our particle data.
// These must match the structures we define in C++.
// 'binding = 0' and 'binding = 1' link them to the buffers we'll set up.
layout(std430, binding = 0) buffer PositionBuffer {
    vec2 positions[];
};

layout(std430, binding = 1) buffer VelocityBuffer {
    vec2 velocities[];
};

// Uniforms are global variables sent from our C++ application.
uniform float deltaTime;
uniform float gravity;

void main() {
    // Get the unique ID of the current thread. This tells us which particle to process.
    // If we have 50,000 particles, this ID will range from 0 to 49,999.
    uint id = gl_GlobalInvocationID.x;

    // --- The Physics Logic (almost identical to the C++ version) ---

    // Define window boundaries
    float boundary_left = -1.0;
    float boundary_right = 1.0;
    float boundary_bottom = -1.0;
    float boundary_top = 1.0;

    // 1. Apply Gravity: Update velocity
    velocities[id].y -= gravity * deltaTime;

    // 2. Update Position
    positions[id] += velocities[id] * deltaTime;

    // 3. Handle Collisions
    if (positions[id].x > boundary_right) {
        positions[id].x = boundary_right;
        velocities[id].x *= -0.8; // Reverse and damp
    } else if (positions[id].x < boundary_left) {
        positions[id].x = boundary_left;
        velocities[id].x *= -0.8;
    }

    if (positions[id].y < boundary_bottom) {
        positions[id].y = boundary_bottom;
        velocities[id].y *= -0.8;
    } else if (positions[id].y > boundary_top) {
        positions[id].y = boundary_top;
        velocities[id].y *= -0.8;
    }
}
