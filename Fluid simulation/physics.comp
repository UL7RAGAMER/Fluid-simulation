#version 430 core
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

// BINDING 0: Particle Positions (Read/Write)
layout(std430, binding = 0) buffer PositionBuffer {
    vec2 positions[];
};

// BINDING 1: Particle Velocities (Read/Write)
layout(std430, binding = 1) buffer VelocityBuffer {
    vec2 velocities[];
};

// BINDING 2: Particle Densities (Read-only)
layout(std430, binding = 2) readonly buffer DensityBuffer {
    float densities[];
};

// BINDING 3: Particle Pressures (Read-only)
layout(std430, binding = 3) readonly buffer PressureBuffer {
    float pressures[];
};


// --- Uniforms ---
uniform uint particleCount;
uniform float deltaTime;
uniform float gravity;
uniform float u_time; // For random damping
uniform float is_mouse_pressed;
uniform vec2 mouse_pos;
// --- SPH Parameters ---
uniform float particleMass;
uniform float smoothingRadius;
uniform float viscosityConstant;
uniform float boundaryDamping;
uniform float boundaryStiffness;
uniform float pressure_multipiler;
// --- SPH Kernel Function Gradients/Laplacians ---
const float PI = 3.14159265359;
const float SPIKY_GRAD_COEFF = -45.0 / PI;
const float VISC_LAP_COEFF = 45.0 / PI;


uniform float boundary_limit;   // half-width of the simulation domain, e.g. 1.0
uniform float boundary_radius;  // region (distance from wall) where wall force acts

float spiky_kernel_gradient(float dist, float h) {
    if (dist > h) return 0.0;
    float term = h - dist;
    return (SPIKY_GRAD_COEFF / pow(h, 6.0)) * term * term;
}

float viscosity_kernel_laplacian(float dist, float h) {
    if (dist > h) return 0.0;
    return (VISC_LAP_COEFF / pow(h, 6.0)) * (h - dist);
}

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= particleCount) return;

    // Read particle's own data
    vec2 pos_i = positions[id];
    vec2 vel_i = velocities[id];
    float density_i = densities[id];
    float pressure_i = pressures[id];
    // safety guards
    if (isnan(pos_i.x) || isnan(pos_i.y) || isinf(pos_i.x) || isinf(pos_i.y)) {
        pos_i = vec2(0.0, 0.0);
        vel_i = vec2(0.0, 0.0);
    }
    if (density_i <= 0.0 || isnan(density_i) || isinf(density_i)) {
        density_i = 1e-4;
    }
    if (pressure_i != pressure_i) { // NaN check: NaN != NaN
        pressure_i = 0.0;
    }

    if (density_i < 0.01) {
        density_i = 0.01;
    }

    // Initialize forces
    vec2 force_pressure = vec2(0.0);
    vec2 force_viscosity = vec2(0.0);
    // CHANGE 1: Initialize a mouse force vector
    vec2 force_mouse = vec2(0.0);

    // Calculate forces by iterating through all other particles
    for (uint j = 0; j < particleCount; j++) {
        if (id == j) continue;

        vec2 r_vec = pos_i - positions[j];
        float dist = length(r_vec);

        if (dist > 0.0 && dist < smoothingRadius) {
            vec2 r_dir = r_vec / dist;
            float density_j = densities[j];
            
            // Pressure Force
            float shared_pressure = (pressure_i + pressures[j]) / 2.0;
            vec2 pressure_grad = r_dir * particleMass * (shared_pressure / density_j) * spiky_kernel_gradient(dist, smoothingRadius);
            force_pressure -= pressure_grad * pressure_multipiler;

            // Viscosity Force
            float visc_lap = viscosity_kernel_laplacian(dist, smoothingRadius);
            vec2 vel_diff = velocities[j] - vel_i;
            force_viscosity += viscosityConstant * particleMass * vel_diff / density_j * visc_lap;
        }
    }
    
    // External Force (Gravity)
    vec2 gravity_accel = vec2(0.0, -gravity);
    // CHANGE 2: Calculate the mouse force here, before integration
    // Using "> 0.5" is safer for floats than "== 1.0"
    if (is_mouse_pressed > 0.5) {
        vec2 from_mouse = pos_i - mouse_pos;
        float dist_to_mouse = length(from_mouse);
        float mouse_radius = 0.19; // The mouse will only affect particles within this radius

        if (dist_to_mouse < mouse_radius) {
            // This creates a force that pushes particles away from the mouse, getting weaker with distance
            force_mouse = normalize(from_mouse) * 150.0 * (mouse_radius + dist_to_mouse);
        }
    }

    // --- Boundary forces (pre-integration push) ---
    // local per-particle boundary force
    vec2 force_boundary = vec2(0.0);

    // left
    float dist_left = pos_i.x - (-boundary_limit);
    if (dist_left < boundary_radius) {
        float penetration = (boundary_radius - dist_left);
        force_boundary.x += boundaryStiffness * penetration * penetration * particleMass; // scaled by mass
    }
    // right
    float dist_right = (boundary_limit) - pos_i.x;
    if (dist_right < boundary_radius) {
        float penetration = (boundary_radius - dist_right);
        force_boundary.x -= boundaryStiffness * penetration * penetration * particleMass;
    }
    // bottom
    float dist_bottom = pos_i.y - (-boundary_limit);
    if (dist_bottom < boundary_radius) {
        float penetration = (boundary_radius - dist_bottom);
        force_boundary.y += boundaryStiffness * penetration * penetration * particleMass;
    }
    // top
    float dist_top = (boundary_limit) - pos_i.y;
    if (dist_top < boundary_radius) {
        float penetration = (boundary_radius - dist_top);
        force_boundary.y -= boundaryStiffness * penetration * penetration * particleMass;
    }

    // --- Sum forces; convert to acceleration ---
    // force_pressure and force_viscosity are forces (scaled by mass in loop)
    vec2 total_force = force_pressure + force_viscosity + force_mouse + force_boundary;
    // acceleration from those forces:
    vec2 accel_from_forces = total_force / 1; // avoid div0
    // total acceleration includes gravity
    vec2 acceleration = accel_from_forces + gravity_accel;

    // --- Integrate (semi-implicit Euler: update velocity from accel, then position from new velocity) ---
    // semi-implicit helps stability: v_{t+dt} = v_t + a*dt ; x_{t+dt} = x_t + v_{t+dt}*dt
    vel_i += acceleration * deltaTime;
    pos_i += vel_i * deltaTime;

    // --- Post-integration position clamping & velocity damping to prevent tunnelling ---
    float epsilon = 1e-4;
    // left wall clamp
    if (pos_i.x < -boundary_limit + epsilon) {
        pos_i.x = -boundary_limit + epsilon;
        vel_i.x = -vel_i.x * boundaryDamping;
    }
    // right wall clamp
    if (pos_i.x > boundary_limit - epsilon) {
        pos_i.x = boundary_limit - epsilon;
        vel_i.x = -vel_i.x * boundaryDamping;
    }
    // bottom clamp
    if (pos_i.y < -boundary_limit + epsilon) {
        pos_i.y = -boundary_limit + epsilon;
        vel_i.y = -vel_i.y * boundaryDamping;
    }
    // top clamp
    if (pos_i.y > boundary_limit - epsilon) {
        pos_i.y = boundary_limit - epsilon;
        vel_i.y = -vel_i.y * boundaryDamping;
    }

    // small velocity threshold to reduce jitter at rest
    if (length(vel_i) < 1e-4) vel_i = vec2(0.0);
    // global velocity damping to remove small oscillations (per-frame)
    float globalDamping = 1.0 - clamp(0.25 * deltaTime, 0.0, 0.25); // 0.75..1.0
    vel_i *= globalDamping;

        // emergency clamps
    if (length(vel_i) > 20.0) vel_i = normalize(vel_i) * 20.0;
    if (length(pos_i) > 100.0) pos_i = clamp(pos_i, vec2(-1e2), vec2(1e2)); // safety

    // --- WRITE FINAL DATA ---
    positions[id] = pos_i;
    velocities[id] = vel_i;

    // CHANGE 4: Delete the old, incorrect mouse interaction code from the end of the shader.
}
