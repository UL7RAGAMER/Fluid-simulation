#version 430 core
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

// BINDING 0: Particle Positions (Read/Write)
layout(std430, binding = 0) buffer PositionBuffer {
    vec2 positions[];
};

// BINDING 1: Particle Velocities (Read/Write)
layout(std430, binding = 1) buffer VelocityBuffer {
    vec2 velocities[];
};

// BINDING 2: Particle Densities (Read-only)
layout(std430, binding = 2) readonly buffer DensityBuffer {
    float densities[];
};

// BINDING 3: Particle Pressures (Read-only)
layout(std430, binding = 3) readonly buffer PressureBuffer {
    float pressures[];
};


// --- Uniforms ---
uniform uint particleCount;
uniform float deltaTime;
uniform float gravity;
uniform float u_time; // For random damping
uniform float is_mouse_pressed;
uniform vec2 mouse_pos;
// --- SPH Parameters ---
uniform float particleMass;
uniform float smoothingRadius;
uniform float viscosityConstant;
uniform float boundaryDamping;
uniform float boundaryStiffness;
uniform float pressure_multipiler;
// --- Surface tension ---
uniform float surfaceTension;    // strength (tune this)
uniform float surfaceThreshold; 
const float maxSurfaceForce = 5000.0;
// min |grad c| to consider surface (e.g. 0.01)
// --- SPH Kernel Function Gradients/Laplacians ---
const float PI = 3.14159265359;
const float SPIKY_GRAD_COEFF = -45.0 / PI;
const float VISC_LAP_COEFF = 45.0 / PI;


uniform float boundary_limit;   // half-width of the simulation domain, e.g. 1.0
uniform float boundary_radius;  // region (distance from wall) where wall force acts



float kernel_W(float dist, float h) {
    if (dist >= h) return 0.0;
    float t = (h - dist);
    // normalized by h^3 to keep scale relative to smoothingRadius
    return (t * t * t) / (h * h * h + 1e-12);
}

// dW/dr (radial derivative). gradient = (dW/dr) * r_dir
float kernel_dW_dr(float dist, float h) {
    if (dist <= 0.0 || dist >= h) return 0.0;
    float t = (h - dist);
    // derivative wrt r: d/dr [(h-r)^3] = -3*(h-r)^2
    return -3.0 * (t * t) / (h * h * h + 1e-12);
}

// radial part of laplacian approx (2D): use simple form  d2W/dr2 approx 6*(h-r)/h^3
// We will use this as a working approximation for surface curvature
float kernel_laplacian(float dist, float h) {
    if (dist >= h) return 0.0;
    return 6.0 * (h - dist) / (h * h * h + 1e-12);
}




float spiky_kernel_gradient(float dist, float h) {
    if (dist > h) return 0.0;
    float term = h - dist;
    return (SPIKY_GRAD_COEFF / pow(h, 6.0)) * term * term;
}

float viscosity_kernel_laplacian(float dist, float h) {
    if (dist > h) return 0.0;
    return (VISC_LAP_COEFF / pow(h, 6.0)) * (h - dist);
}

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= particleCount) return;

    // Read particle's own data
    vec2 pos_i = positions[id];
    vec2 vel_i = velocities[id];
    float density_i = densities[id];
    float pressure_i = pressures[id];
    // safety guards
    if (isnan(pos_i.x) || isnan(pos_i.y) || isinf(pos_i.x) || isinf(pos_i.y)) {
        pos_i = vec2(0.0, 0.0);
        vel_i = vec2(0.0, 0.0);
    }
    if (density_i <= 0.0 || isnan(density_i) || isinf(density_i)) {
        density_i = 1e-4;
    }
    if (pressure_i != pressure_i) { // NaN check: NaN != NaN
        pressure_i = 0.0;
    }

    if (density_i < 0.01) {
        density_i = 0.01;
    }

    // Initialize forces
    vec2 force_pressure = vec2(0.0);
    vec2 force_viscosity = vec2(0.0);
    // mouse force
    vec2 force_mouse = vec2(0.0);

    // --- Surface tension accumulators (2D-friendly, using existing kernels) ---
    vec2 colorFieldGrad = vec2(0.0);
    float colorFieldLaplacian = 0.0;

    // Calculate forces by iterating through all other particles
    for (uint j = 0; j < particleCount; j++) {
        if (id == j) continue;

        vec2 r_vec = pos_i - positions[j];
        float dist = length(r_vec);

        if (dist > 0.0 && dist < smoothingRadius) {
            vec2 r_dir = r_vec / dist;
            float density_j = densities[j];
            
            // Pressure Force
            float shared_pressure = (pressure_i + pressures[j]) / 2.0;
            vec2 pressure_grad = r_dir * particleMass * (shared_pressure / (density_j + 1e-6)) * spiky_kernel_gradient(dist, smoothingRadius);
            force_pressure -= pressure_grad * pressure_multipiler;

            // Viscosity Force
            float visc_lap = viscosity_kernel_laplacian(dist, smoothingRadius);
            vec2 vel_diff = velocities[j] - vel_i;
            force_viscosity += viscosityConstant * particleMass * vel_diff / (density_j + 1e-6) * visc_lap;

            // --- Surface tension contributions (2D) ---
            // Use spiky gradient for color gradient contribution and visc laplacian for color laplacian
            float dWdr = kernel_dW_dr(dist, smoothingRadius);
            colorFieldGrad += (particleMass / density_j) * r_dir * dWdr;

            float lapW = kernel_laplacian(dist, smoothingRadius);
            colorFieldLaplacian += (particleMass / density_j) * lapW;
        }
    }


    vec2 force_surface = vec2(0.0);
    float grad_len = length(colorFieldGrad);
    if (grad_len > 0.0 && grad_len > surfaceThreshold) {
        // curvature estimate kappa ~= colorFieldLaplacian / |grad c|
        float curvature = colorFieldLaplacian / (grad_len + 1e-2);
        // f_s = - sigma * curvature * n_hat * |grad c|
        // simplified to: -sigma * (lap / |grad|) * grad

        force_surface = surfaceTension * curvature * colorFieldGrad;

        // clamp to avoid explosions
        float fs_len = length(force_surface);
        if (fs_len > maxSurfaceForce) {
            force_surface = (force_surface / fs_len) * maxSurfaceForce;
        }
    }
    // External Force (Gravity)
    vec2 gravity_accel = vec2(0.0, -gravity);

    // Mouse force (pre-integration)
    if (is_mouse_pressed > 0.5) {
        vec2 from_mouse = pos_i - mouse_pos;
        float dist_to_mouse = length(from_mouse);
        float mouse_radius = 0.19; // The mouse will only affect particles within this radius

        if (dist_to_mouse < mouse_radius && dist_to_mouse > 0.0) {
            float force_magnitude = 150.0 * (1.0 - (dist_to_mouse / mouse_radius));
            force_mouse = normalize(from_mouse) * force_magnitude;
        }
    }


    // --- Boundary forces (pre-integration push) ---
    vec2 force_boundary = vec2(0.0);

    // left
    float dist_left = pos_i.x - (-boundary_limit);
    if (dist_left < boundary_radius) {
        float penetration = (boundary_radius - dist_left);
        force_boundary.x += boundaryStiffness * penetration;
    }
    // right
    float dist_right = (boundary_limit) - pos_i.x;
    if (dist_right < boundary_radius) {
        float penetration = (boundary_radius - dist_right);
        force_boundary.x -= boundaryStiffness * penetration ;
    }
    // bottom
    float dist_bottom = pos_i.y - (-boundary_limit);
    if (dist_bottom < boundary_radius) {
        float penetration = (boundary_radius - dist_bottom);
        force_boundary.y += boundaryStiffness * penetration ;
    }
    // top
    float dist_top = (boundary_limit) - pos_i.y;
    if (dist_top < boundary_radius) {
        float penetration = (boundary_radius - dist_top);
        force_boundary.y -= boundaryStiffness * penetration ;
    }

    // --- Surface tension force (compute after loop) ---

    // --- Sum forces; convert to acceleration ---
    vec2 total_force = force_pressure + force_viscosity + force_mouse + force_boundary + force_surface;
    vec2 accel_from_forces = total_force / 1.0; // mass normalization if needed
    vec2 acceleration = accel_from_forces + gravity_accel;
    // global damping: tune this small (e.g. 0.1 - 2.0)
    float globalDamping = 1.0; // try values 0.2..2.0 externally, or make uniform
    // apply damping proportional to timestep
    vel_i *= clamp(1.0 - globalDamping * deltaTime, 0.0, 1.0);
    // --- Integrate (semi-implicit Euler) ---
    vel_i += acceleration * deltaTime;
    pos_i += vel_i * deltaTime;


    // Final safety check to prevent writing NaN/inf back to the buffer
    if (isnan(vel_i.x) || isnan(vel_i.y) || isinf(vel_i.x) || isinf(vel_i.y)) {
        vel_i = vec2(0.0);
        pos_i = vec2(random(pos_i), random(pos_i+0.5)); // Reset to a random position
    }

    // --- WRITE FINAL DATA ---
    positions[id] = pos_i; 
    velocities[id] = vel_i;

}
