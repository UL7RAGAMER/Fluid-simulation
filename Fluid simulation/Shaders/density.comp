    #version 430 core
    layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

    // BINDING 0: Particle Positions (Read-only)
    layout(std430, binding = 0) readonly buffer PositionBuffer {
        vec2 positions[];
    };

    // BINDING 1: Particle Densities (Write-only)
    layout(std430, binding = 1) writeonly buffer DensityBuffer {
        float densities[];
    };

    // BINDING 2: Particle Pressures (Write-only)
    layout(std430, binding = 2) writeonly buffer PressureBuffer {
        float pressures[];
    };

    // --- Uniforms ---
    uniform uint particleCount;

    // --- SPH Parameters ---
    uniform float particleMass;
    uniform float smoothingRadius; // The core interaction radius 'h'
    uniform float gasConstant;     // Relates density to pressure (k)
    uniform float restDensity;     // The target density of the fluid (rho0)

    // --- SPH Kernel Functions ---
    // Poly6 kernel constants: W_poly6(r, h) = (315 / (64 * pi * h^9)) * (h^2 - r^2)^3
    const float PI = 3.14159265359;
    const float POLY6_BASE = 4/ (PI);

    float poly6_kernel(float distSq, float h) {
        float h2 = h * h;
        if (distSq >= h2) return 0.0;
        float term = (h2 - distSq);
        // POLY6_BASE / (h^9) * term^3
        return (POLY6_BASE / pow(h, 8.0)) * (term * term);
    }

    void main() {
        uint id = gl_GlobalInvocationID.x;
        if (id >= particleCount) return;

        vec2 pos_i = positions[id];
        float density = 0.0;

        // Brute-force neighbor summation (O(N^2)). Replace with spatial hashing / grid for speed.
        float h = smoothingRadius;
        float h2 = h * h;

        for (uint j = 0; j < particleCount; j++) {
            vec2 pos_j = positions[j];
            vec2 r_vec = pos_i - pos_j;
            float distSq = dot(r_vec, r_vec);

            if (distSq < h2) {
                // Sum contribution: m * W_poly6(r^2, h)
                density += particleMass * poly6_kernel(distSq, h);
            }
        }

        // Safety clamp: avoid zero or extremely small density (helps later divisions)
        const float DENSITY_EPS = 1e-4;
        if (density < DENSITY_EPS) density = DENSITY_EPS;

        densities[id] = density;

        // Equation of state: p = k * (rho - rho0)
        // Clamp to non-negative pressure to reduce tensile instability (optional, but recommended for stability)
        float p = gasConstant * (density - restDensity);
        if (p < 0.0) p = 0.0;

        pressures[id] = p;
    }
